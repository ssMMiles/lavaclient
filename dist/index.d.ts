// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../@lavaclient/types
//   ../tiny-typed-emitter

import Lavalink, { Filter } from "@lavaclient/types";
import { TypedEmitter } from "tiny-typed-emitter";
import type * as Lavalink from "@lavaclient/types";



export class Player<N extends Node = Node> extends TypedEmitter<PlayerEvents> {
    readonly node: N;
    static USE_FILTERS: boolean;
    readonly guildId: Snowflake;
    channelId: string | null;
    track?: string;
    trackData?: Lavalink.TrackInfo;
    playing: boolean;
    playingSince?: number;
    paused: boolean;
    position?: number;
    connected: boolean;
    filters: Partial<Lavalink.FilterData>;
    lastUpdatedTimestamp?: number;
    constructor(node: N, guild: Snowflake | DiscordResource);
    get accuratePosition(): number | undefined;
    get volume(): number;
    connect(channel: Snowflake | DiscordResource | null, options?: ConnectOptions): Promise<this>;
    disconnect(): Promise<this>;
    play(track: string | {
        track: string;
    }, options?: PlayOptions): Promise<this>;
    stop(): Promise<this>;
    pause(state?: boolean): Promise<this>;
    resume(): Promise<this>;
    seek(position: number): Promise<this>;
    destroy(): Promise<this>;
    setVolume(volume: number): Promise<this>;
    setEqualizer(...gains: number[]): Promise<this>;
    setEqualizer(...bands: Lavalink.EqualizerBand[]): Promise<this>;
    setFilters(): Promise<this>;
    setFilters(filters: Partial<Lavalink.FilterData>): Promise<this>;
    setFilters<F extends Filter>(filter: F, data: Lavalink.FilterData[F]): Promise<this>;
    handleVoiceUpdate(update: VoiceStateUpdate | VoiceServerUpdate): Promise<this>;
    handleEvent(event: Lavalink.PlayerEvent): void;
}
export type PlayOptions = Omit<Lavalink.PlayData, "track">;
export interface PlayerEvents {
    disconnected: (code: number, reason: string, byRemote: boolean) => void;
    trackStart: (track: string) => void;
    trackEnd: (track: string | null, reason: Lavalink.TrackEndReason) => void;
    trackException: (track: string | null, error: Error) => void;
    trackStuck: (track: string | null, thresholdMs: number) => void;
    channelJoin: (joined: Snowflake) => void;
    channelLeave: (left: Snowflake) => void;
    channelMove: (from: Snowflake, to: Snowflake) => void;
}
export interface ConnectOptions {
    deafened?: boolean;
    muted?: boolean;
}
export interface VoiceServerUpdate {
    token: string;
    endpoint: string;
    guild_id: `${bigint}`;
}
export interface VoiceStateUpdate {
    session_id: string;
    channel_id: `${bigint}` | null;
    guild_id: `${bigint}`;
    user_id: `${bigint}`;
}

export type Snowflake = string;
export type DiscordResource = {
    id: Snowflake;
};
export type Dictionary<V = any, K extends string | symbol = string> = Record<K, V>;
export type Manager = Node | Cluster;
export interface ManagerOptions {
    sendGatewayPayload: SendGatewayPayload;
    user?: Snowflake | DiscordResource;
}
export function getId(value: Snowflake | DiscordResource): Snowflake;

export class Cluster extends TypedEmitter<ClusterEvents> {
    readonly nodes: Map<string, ClusterNode>;
    readonly sendGatewayPayload: SendGatewayPayload;
    userId?: Snowflake;
    constructor(options: ClusterOptions);
    get rest(): REST | null;
    get idealNodes(): ClusterNode[];
    connect(user?: Snowflake | DiscordResource | undefined): void;
    createPlayer(guild: Snowflake | DiscordResource, nodeId?: string): Player<ClusterNode>;
    getPlayer(guild: Snowflake | DiscordResource): Player<ClusterNode> | null;
    destroyPlayer(guild: Snowflake | DiscordResource): boolean;
    handleVoiceUpdate(update: VoiceServerUpdate | VoiceStateUpdate): void;
    getNode(guild: Snowflake | DiscordResource): ClusterNode | null;
}
export interface ClusterEvents {
    nodeConnect: (node: ClusterNode, event: ConnectEvent) => void;
    nodeDisconnect: (node: ClusterNode, event: DisconnectEvent) => void;
    nodeError: (node: ClusterNode, error: Error) => void;
    nodeDebug: (node: ClusterNode, message: string) => void;
    nodeRaw: (node: ClusterNode, message: Lavalink.IncomingMessage) => void;
}
export interface ClusterOptions extends ManagerOptions {
    nodes: ClusterNodeOptions[];
}
export interface ClusterNodeOptions extends ConnectionInfo {
    id: string;
}

export class ClusterNode extends Node {
    readonly cluster: Cluster;
    readonly id: string;
    constructor(cluster: Cluster, id: string, info: ConnectionInfo);
    emit<U extends keyof NodeEvents>(event: U, ...args: Parameters<NodeEvents[U]>): boolean;
}

export class Node extends TypedEmitter<NodeEvents> {
    static DEBUG_FORMAT: string;
    static DEBUG_FORMAT_PLAYER: string;
    static DEFAULT_STATS: Lavalink.StatsData;
    readonly players: Map<string, Player<this>>;
    readonly conn: Connection;
    readonly rest: REST;
    readonly sendGatewayPayload: SendGatewayPayload;
    state: NodeState;
    stats: Lavalink.StatsData;
    userId?: Snowflake;
    constructor(options: NodeOptions);
    get penalties(): number;
    connect(user?: Snowflake | DiscordResource | undefined): void;
    createPlayer(guild: Snowflake | DiscordResource): Player<this>;
    destroyPlayer(guild: Snowflake | DiscordResource): boolean;
    handleVoiceUpdate(update: VoiceStateUpdate | VoiceServerUpdate): void;
    debug(topic: string, message: string, player?: Player): void;
}
export type SendGatewayPayload = (id: Snowflake, payload: {
    op: 4;
    d: Dictionary;
}) => void;
export interface NodeEvents {
    connect: (event: ConnectEvent) => void;
    disconnect: (event: DisconnectEvent) => void;
    closed: () => void;
    error: (error: Error) => void;
    debug: (message: string) => void;
    raw: (message: Lavalink.IncomingMessage) => void;
}
export interface ConnectEvent {
    took: number;
    reconnect: boolean;
}
export interface DisconnectEvent {
    code: number;
    reason: string;
    reconnecting: boolean;
    wasClean: boolean;
}
export interface NodeOptions extends ManagerOptions {
    connection: ConnectionInfo;
}

export enum NodeState {
    Idle = 0,
    Connecting = 1,
    Connected = 2,
    Disconnecting = 3,
    Disconnected = 4,
    Reconnecting = 5
}

export class Connection {
    readonly node: Node;
    readonly info: ConnectionInfo;
    static CLIENT_NAME: string;
    reconnectTry: number;
    payloadQueue: OutgoingPayload[];
    connectedAt?: number;
    constructor(node: Node, info: ConnectionInfo);
    get active(): boolean;
    get canReconnect(): boolean;
    get uptime(): number;
    send(important: boolean, data: Lavalink.OutgoingMessage): Promise<void>;
    connect(): void;
    disconnect(code?: number, reason?: string): void;
    configureResuming(): Promise<void>;
    flushQueue(): void;
    reconnect(): boolean;
}
export type ReconnectDelay = (current: number) => number | Promise<number>;
export interface ConnectionInfo {
    host: string;
    port: number;
    password: string;
    secure?: boolean;
    resuming?: ResumingOptions;
    reconnect?: ReconnectOptions;
}
export interface ResumingOptions {
    key: string;
    timeout?: number;
}
export interface ReconnectOptions {
    delay?: number | ReconnectDelay;
    tries?: number;
}
export interface OutgoingPayload {
    resolve: () => void;
    reject: (error: Error) => void;
    data: Lavalink.OutgoingMessage;
}

export class REST {
    readonly node: Node;
    constructor(node: Node);
    get baseUrl(): string;
    loadTracks(identifier: string): Promise<Lavalink.LoadTracksResponse>;
    decodeTracks(...tracks: string[]): Promise<Lavalink.TrackInfo[]>;
    decodeTrack(track: string): Promise<Lavalink.TrackInfo>;
    do<T>(endpoint: string, options?: Options): Promise<T>;
}
export type Options = {
    method?: string;
    data?: any;
};

export const TRACK_INFO_VERSIONED = 1, TRACK_INFO_VERSION = 2;
export const decoders: Record<number, TrackInfoDecoder>;
export function decode(data: Uint8Array | string): TrackInfo | null;
export type TrackInfo = import("@lavaclient/types").TrackInfo & {
    version: number;
};
export type TrackInfoDecoder = (input: DataInput) => TrackInfo | null;

export class DataInput {
    constructor(data: Uint8Array | string);
    readByte(): number;
    readBoolean(): boolean;
    readUnsignedShort(): number;
    readInt(): number;
    readLong(): BigInt;
    readUTF(): string;
}

